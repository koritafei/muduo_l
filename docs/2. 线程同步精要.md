## 线程同步精要
并发编程的两种模型：
1. `message passing`
2. `shared memory`

运行在多台机器上的并行编程只有一种模型`message passing`。
线程同步的四原则：
1. 尽量最低限度的共享对象，减少需要同步的场合。一个对象不暴露给其他线程，就不要暴露，如果需要暴露考虑`immutable` 对象。
2. 使用高级的并发构件；
3. 使用底层的同步原语，只用非递归的互斥器和条件变量，慎用读写锁，不用信号量；
4. 除了使用`atomic`整数之外，不自己编写`lock_free`代码。

### 互斥器(`mutex`)
互斥器使用的首要原则：
1. 用`RAII`手法封装`mutex`的创建、销毁、加锁和解锁四个过程；
2. 只用非递归的`mutex`;
3. 不手工调用`lock()和unlock()`；一切交给**栈上的`Guard`对象的创建和销毁负责**;
4. 在每次调用`Guard`对象时，考虑当前调用栈上已经持有的锁，防止加锁顺序不同导致的死锁。

次要原则：
1. 不使用跨进程的`mutex`, 进程间的通信只使用`TCP Sockets`；
2. 加锁，解锁只能在同一个线程；
3. 不要忘了解锁，不能重复解锁；
4. 必要时可以使用`PTHREAD_MUTEX_ERRORCHECK`来排错。

#### 只使用非递归的`mutex`
在使用非递归的`mutex`时，重复加锁会导致死锁，为防止用户使用了非加锁版本，可以在非加锁版本中提供一个`isLockByThisThread`来判断是否被当前线程加锁。
### 条件变量(`condition variable`)
如果需要等待某个条件成立，这时需要使用条件变量(`condition variable`)。
条件变量是一个或多个线程等待某个布尔表达式为真，即等待别的线程唤醒它。又称为管程(`monitor`).
使用方式：
`wait`端：
1. 必须与`mutex`一起使用，该布尔表达式的读写受`mutex`保护；
2. 在`mutex`上锁时，才能调用`wait`；
3. 把判断布尔条件和`wait`放到`while`循环中。

为什么将布尔条件判断和`wait`放入`while`循环中？
> 主要是避免`spurious wakeup`(虚假唤醒)。
> 虚假唤醒是指一个线程调用了`pthread_cond_nofity`,多个调用`pthread_cond_wait`的线程被唤醒；

`linux`为什么设置`spurious wakeup`?
> 在`linux`中，`pthread_cond_wait`底层是`futex`系统调用。
> 在`linux`中，任何慢速的阻塞的系统调用当接收到信号时，就会返回`-1`,并设置`errno为EINTR`.在系统调用返回前，用户程序注册信号处理函数会被处理。

为什么`linux`的慢速系统调用会设置`EINTR`?
> 1. 慢速的系统调用，有可能会被永远阻塞的不被执行，当接收到信号时，认为是一个返回并执行其他代码的时机；
> 2. 有些慢系统调用阻塞后会自动重启，所以我们会用`siginterrupt(signo, 1)`来关闭重启，或在用`sigaction`安装信号处理函数时，取消`SA_RESTART`标志。之后通过判断信号返回值是否时`-1或errno是否为EINTR`来判断信号是否返回。
> 3. 关闭了`SA_RESTART`的系统调用，一般采用`while()`循环监测，监测到`EINTR`就重新启动。

`signal/broadcast`端：
1. 不一定在`mutex`已上锁的情况下调用`signal`；
2. 在`signal`之前一般要修改布尔表达式的值；
3. 修改布尔表达式需要`mutex`保护；
4. 注意区分`signal和boardcast`：
   > `boardcast`表示状态变化；
   > `signal`表示资源可用。

倒计时(`CountDownLatch`)是一种常用且易用的同步手段，作用有以下几个方面：
1. 主线程启动多个子线程，等待这些子线程各自完成一定的任务后，主线程继续执行。通常用于主线程等待多个子线程初始化完成；
2. 主线程启动多个子线程，子线程等待主线程，主线程完成其他一些任务后，通知子线程开始执行，子线程等待主线程起跑命令。

```cpp
class CountDownLatch: boost::noncapyable{
public:
  explicit CountDownLatch(int count):mutex_(),cond_(mutex_)count_(count){}

  void wait(){
    // 等待计数值变为0 
    MutexLockGuard lock(mutex_);
    while(count_ > 0) {
      cond_.wait()
    }
  }

  void countDown(){
    // 计数值减1
    MutexLockGuard lock(mutex_);
    --count_;
    if(0 == count_) {
      cond_.notifyAll();
    }
  }

private:
  mutable MutexLock mutex_;
  Condition cond_;
  int count_; // 倒数次数
};
```
### 不要用读写锁和信号量
### `MutexLock`, `MutexLockGuard`和`Condotion`封装
```cpp
#include <assert.h>
#include <pthread.h>
#include <sys/syscall.h>

#include <boost/core/noncopyable.hpp>

#define MCHECK(ret)                                                            \
  ({                                                                           \
    __typeof__(ret) errnum = (ret);                                            \
    if (__builtin_expect(errnum != 0, 0)) {                                    \
      __assert_perror_fail(errnum, __FILE__, __LINE__, __func__);              \
    }                                                                          \
  })

class MutexLock : boost::noncopyable {
public:
  MutexLock() : holder_(0) {
    MCHECK(pthread_mutex_init(&mutex_, nullptr));
  }

  ~MutexLock() {
    assert(holder_ == 0);
    MCHECK(pthread_mutex_destroy(&mutex_));
  }

  bool isLockedByThisThread() const {
    return holder_ == ::syscall(SYS_gettid);
  }

  void assertLocked() const {
    assert(isLockedByThisThread());
  }

  void lock() {
    MCHECK(pthread_mutex_lock(&mutex_));
    assignHoder();
  }

  void unlock() {
    unassignHoder();
    MCHECK(pthread_mutex_unlock(&mutex_));
  }

  pthread_mutex_t *getMutex() {
    return &mutex_;
  }

private:
  pthread_mutex_t mutex_;
  pid_t           holder_;
  friend class Condition;

  class UnassignGuard : boost::noncopyable {
  public:
    explicit UnassignGuard(MutexLock &mutex) : owner_(mutex) {
      owner_.unassignHoder();
    }

    ~UnassignGuard() {
      owner_.assignHoder();
    }

  private:
    MutexLock &owner_;
  };

  void unassignHoder() {
    holder_ = 0;
  }

  void assignHoder() {
    holder_ = static_cast<pid_t>(::syscall(SYS_gettid));
  }

};  // class MutexLock

class MutexLockGuard : boost::noncopyable {
public:
  explicit MutexLockGuard(MutexLock &mutex) : mutex_(mutex) {
    mutex_.lock();
  }

  ~MutexLockGuard() {
    mutex_.unlock();
  }

private:
  MutexLock &mutex_;
};
```
`Condition`封装:
```cpp
class Condition : boost::noncopyable {
public:
  explicit Condition(muduo::MutexLock &mutex) : mutex_(mutex) {
    MCHECK(pthread_cond_init(&cond_, nullptr));
  }

  ~Condition() {
    MCHECK(pthread_cond_destroy(&cond_));
  }

  void wait() {
    muduo::MutexLock::UnassignGuard ug(mutex_);
    MCHECK(pthread_cond_wait(&cond_, mutex_.getPthreadMutex()));
  }

  void notify() {
    MCHECK(pthread_cond_signal(&cond_));
  }

  void notifyAll() {
    MCHECK(pthread_cond_broadcast(&cond_));
  }

  void waitForSeconds(double seconds) {
    struct timespec abstime;
    clock_gettime(CLOCK_REALTIME, &abstime);
    const int kNanoSecondsPerSecond = 1000 * 1000;

    int64_t nanoSeconds = static_cast<int64_t>(seconds * kNanoSecondsPerSecond);
    abstime.tv_sec += static_cast<time_t>((abstime.tv_nsec + nanoSeconds) /
                                          kNanoSecondsPerSecond);
    abstime.tv_nsec = static_cast<int64_t>((abstime.tv_nsec + nanoSeconds) %
                                           kNanoSecondsPerSecond);
    muduo::MutexLock::UnassignGuard ug(mutex_);
    return ETIMEDOUT ==
           pthread_cond_timedwait(&cond_, mutex_.getPthreadMutex(), &abstime);
  }

private:
  muduo::MutexLock &mutex_;
  pthread_cond_t    cond_;
};
```

线程安全的单例模式：
```cpp
template <typename T>
class Singleton : boost::noncapyable{
public:
  static T &instance(){
    pthread_once(&once_, &Singleton::init);
    return *value_;
  }
private:
  Singleton();
  ~Singleton();

  static void init() {
    value_ = new T();
  }

  static pthread_once_t once_;
  static T *value_;
};

template<typename T>
pthread_once_t Singleton<T>::once_= PTHREAD_ONCE_INIT;
template<typename T>
T *Singleton<T::value_ = nullptr;
```


