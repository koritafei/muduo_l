## 线程安全的对象生命周期管理
编写线程安全的类容易，使用同步原语(`syncronization primitives`)保护内部状态即可。
**对象的生死不能通过对象自身拥有的`mutex`(互斥器)来保护。**
如何避免对象析构时可能存在的`race condition`(竞态条件)是`C++`多线程编程面临的基本问题。
借助`Boost`库中`shared_ptr`和`weak_ptr`可以完美解决上述问题。
### 当析构函数遇到多线程
当一个对象可以被多个线程同时看见，就会在对象销毁时出现多种竞态条件(`race condition`):
1. 在销毁一个对象时，如何得知是否有别的线程正在执行该对象的函数？
2. 如何保证在执行成员函数期间，对象不会被另一个线程析构？
3. 在调用某一个成员函数之前，如何获取该对象的状态，其析构函数不会被执行一半？

通过`shared_ptr`可以一劳永逸的解决上述问题。
#### 线程安全的定义
* 多个线程同时访问时，表现出正确行为；
* 无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织(`interleaving`)其行为正确；
* 调用端代码无需额外的同步或其他协调动作。

#### `MutexLock和MutexLockGuard`
`MutexLock`封装临界区(`critical section`)。
`MutexLockGuard`封装临界区的进入和退出。
`MutexLock`与`MutexLockGuard`实现：
```cpp
#ifndef __MUTEX_H__
#define __MUTEX_H__

#include <assert.h>
#include <pthread.h>

#include "CurrentThread.hpp"
#include "Noncopyable.hpp"

namespace muduo {

#define MCHECK(ret)                                                            \
  ({                                                                           \
    __typeof__(ret) errnum = ret;                                              \
    if (__builtin_expect(errnum != 0, 0)) {                                    \
      __assert_perror_fail(errnum, __FILE__, __LINE__, __func__);              \
    }                                                                          \
  })

class MutexLock : Noncopyable {
public:
  MutexLock() : holder_(0) {
    MCHECK(pthread_mutex_init(&mutex_, NULL));
  }

  ~MutexLock() {
    assert(0 == holder_);
    MCHECK(pthread_mutex_destroy(&mutex_));
  }

  bool isLockedByThisThread() const {
    return holder_ == CurrentThread::tid();
  }

  void assertLocked() const {
    assert(isLockedByThisThread());
  }

  void lock() {
    MCHECK(pthread_mutex_lock(&mutex_));
    assignHolder();
  }

  void unlock() {
    unassignHolder();
    MCHECK(pthread_mutex_unlock(&mutex_));
  }

  pthread_mutex_t *getPthreadMutex() {
    return &mutex_;
  }

private:
  friend class Condition;

  class UnassignGuard : Noncopyable {
  public:
    explicit UnassignGuard(MutexLock &owner) : owner_(owner) {
    }

    ~UnassignGuard() {
      owner_.assignHolder();
    }

  private:
    MutexLock &owner_;
  };

  void unassignHolder() {
    holder_ = 0;
  }

  void assignHolder() {
    holder_ = CurrentThread::tid();
  }

  pid_t           holder_;
  pthread_mutex_t mutex_;
};

class MutexLockGuard : Noncopyable {
public:
  explicit MutexLockGuard(MutexLock &owner) : lock_(owner) {
    lock_.lock();
  }

  ~MutexLockGuard() {
    lock_.unlock();
  }

private:
  MutexLock &lock_;
};

}  // namespace muduo

#endif /* __MUTEX_H__ */
```
### 对象的创建很简单
线程安全的对象构造做到以下几点：
1. 不要在构造函数中注册任何回调函数；
2. 不要在构造函数中将`this`传给跨线程对象；
3. 即使在构造函数的最后一行也不行。

### 线程安全的`Observer`有多难
`C/C++`指针问题根源： 无法有效判断一个指针是否合法。
### 神器`shared_ptr/weak_ptr`
`shared_ptr`的用法的关键点：
* `shared_ptr`控制对象生命周期。`shared_ptr`是强引用，只要存在引用该指针的对象就不会销毁。
* `weak_ptr`不控制生命周期。`weak_ptr`可以检测对象是否存活。
* `shared_ptr/weak_ptr`是原子操作，没有使用锁。
* `shared_ptr/weak_ptr`线程安全级别与`std::string、STL`相同。

`C++`可能出现的内存问题有以下：
1. 缓冲区溢出(`buffer overrun`)
2. 空悬指针/野指针
3. 重复释放(`double delete`)
4. 内存泄漏(`memory leak`)
5. 不配对的`new[]/delete`
6. 内存碎片(`memory fragmentation`)

对前5个问题的解决，可以采用如下方式：
1. 缓冲区溢出：用`std::vector<char>/std::string`或自己写的`Buffer Class`来管理缓冲区，自动标记缓冲区长度，通过成员函数不是裸指针修改缓冲区。
2. 空悬指针/野指针：使用`shared_ptr/weak_ptr`。
3. 重复释放：使用`scoped_ptr`，只在对象析构的时候释放一次。
4. 内存泄漏：用`scoped_ptr`，对象析构时自动释放内存。
5. 不配对的`new[]/delete`: 把`new[]`替换为`std::vector/scoped_array`。

`scoped_ptr/shared_ptr/weak_ptr`都是值语意，要么是栈上对象，要么是其他对象的直接数据成员，或是标准容器库的元素。
#### 再论`shared_ptr`的线程安全
`shared_ptr`本身不是`100%`线程安全的，对象的读写不是线程安全的。线程安全说明如下：
1. 一个`shared_ptr`对象实体可以被多个线程同时读取；
2. 两个`shared_ptr`对象实体可以被两个线程同时写入，析构算写入；
3. 如果要从多个线层读写同一个`shared_ptr`对象，需要加锁。

即： `shared_ptr`本身是线程安全的，但其对象读写是非线程安全的。
#### `shared_ptr`技术与陷阱
1. `shared_ptr`: 意外延长对象的生命周期；
2. 拷贝开销大于原始的指针。
  因此在传递`shared_ptr`对象时，多采用常引用的方式(`const type &`);
  采用常引用的方式避免了拷贝，同时对象在栈上，线程读安全。

3. 析构动作在创建时被捕获。
   * 虚析构不再是必须的；
   * `shared_ptr<void>`可以持有任何对象，并能够安全释放；
   * `shared_ptr`对象可以安全的跨越模块边界，避免了模块`A`的内存在模块`B`中释放时报错；
   * 二进制兼容；
   * 析构函数可定制。

### 对象池与弱回调
```cpp
#ifndef __STOCKFACTORY_H__
#define __STOCKFACTORY_H__

#include <muduo/base/Mutex.h>

#include <boost/noncopyable.hpp>
#include <functional>
#include <map>
#include <memory>

#include "Stock.h"

using std::placeholders::_1;

class StockFactory : public boost::noncopyable,
                     std::enable_shared_from_this<StockFactory> {
public:
  std::shared_ptr<Stock> get(const std::string &key) {
    std::shared_ptr<Stock> pStock;
    muduo::MutexLockGuard  lock(mutex_);
    std::weak_ptr<Stock> & wkStock = stocks_[key];
    pStock                         = wkStock.lock();
    if (!pStock) {
      pStock.reset(new Stock(key),
                   std::bind(&StockFactory::weakDeleteCallback,
                             std::weak_ptr<StockFactory>(shared_from_this()),
                             _1));
      wkStock = pStock;
    }
    return pStock;
  }

private:
  static void weakDeleteCallback(const std::weak_ptr<StockFactory> &wkFactory,
                                 Stock *                            stock) {
    std::shared_ptr<StockFactory> factory(wkFactory.lock());
    if (factory) {
      factory->removeStock(stock);
    }
    delete stock;
  }

  void removeStock(Stock *stock) {
    if (stock) {
      muduo::MutexLockGuard lock(mutex_);
      stocks_.erase(stock->key());
    }
  }

  mutable muduo::MutexLock                    mutex_;
  std::map<std::string, std::weak_ptr<Stock>> stocks_;
};  // class StockFactory

#endif /* __STOCKFACTORY_H__ */
```
分析：
1. 在`StockFactory`中使用了`std::map<std::string, std::weak_ptr<Stock>>` 存储`Stock`对象；如果将`std::weak_ptr`换成`std::shared_ptr`，可能会延长对象的生命周期。所以采用`std::weak_ptr`的形式，但采用该形式时，需要在使用对象时，判断对象是否存在。
2. 上述代码中如果不注册`Stock`对象的析构函数，将对导致内存出现缓慢的泄漏，因为`map`中的元素不做移除，其大小会逐渐增加，导致内存泄漏。因此需要在析构`shared_ptr`对象时，启动`map`中元素移除。
`shared_ptr`提供了`reset`函数，可以用于绑定，在对象析构时调用的函数。
如上述示例中的：
```cpp
pStock.reset(new Stock(key),
                   std::bind(&StockFactory::weakDeleteCallback,
                             std::weak_ptr<StockFactory>(shared_from_this()),
                             _1));
```
注意：在这句代码中隐藏着一个陷阱：
> `std::bind`的第二个参数传递为`this`指针。
> 此时如果直接传递`this`指针，会造成函数线程安全存在问题。
3. 为解决`2`中的问题，引入了`enable_shared_from_this`，将`this`指针转变为`shared_ptr`类型。但如果直接使用`shared_ptr`同样延长了`StockFactory`的生命周期，因此可以将其转为`std::weak_ptr`。




