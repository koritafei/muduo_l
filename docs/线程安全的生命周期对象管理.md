## 线程安全的对象生命周期管理
编写线程安全的类容易，使用同步原语(`syncronization primitives`)保护内部状态即可。
**对象的生死不能通过对象自身拥有的`mutex`(互斥器)来保护。**
如何避免对象析构时可能存在的`race condition`(竞态条件)是`C++`多线程编程面临的基本问题。
借助`Boost`库中`shared_ptr`和`weak_ptr`可以完美解决上述问题。
### 当析构函数遇到多线程
当一个对象可以被多个线程同时看见，就会在对象销毁时出现多种竞态条件(`race condition`):
1. 在销毁一个对象时，如何得知是否有别的线程正在执行该对象的函数？
2. 如何保证在执行成员函数期间，对象不会被另一个线程析构？
3. 在调用某一个成员函数之前，如何获取该对象的状态，其析构函数不会被执行一半？

通过`shared_ptr`可以一劳永逸的解决上述问题。
#### 线程安全的定义
* 多个线程同时访问时，表现出正确行为；
* 无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织(`interleaving`)其行为正确；
* 调用端代码无需额外的同步或其他协调动作。

#### `MutexLock和MutexLockGuard`
`MutexLock`封装临界区(`critical section`)。
`MutexLockGuard`封装临界区的进入和退出。
`MutexLock`与`MutexLockGuard`实现：
```cpp
#ifndef __MUTEX_H__
#define __MUTEX_H__

#include <assert.h>
#include <pthread.h>

#include "CurrentThread.hpp"
#include "Noncopyable.hpp"

namespace muduo {

#define MCHECK(ret)                                                            \
  ({                                                                           \
    __typeof__(ret) errnum = ret;                                              \
    if (__builtin_expect(errnum != 0, 0)) {                                    \
      __assert_perror_fail(errnum, __FILE__, __LINE__, __func__);              \
    }                                                                          \
  })

class MutexLock : Noncopyable {
public:
  MutexLock() : holder_(0) {
    MCHECK(pthread_mutex_init(&mutex_, NULL));
  }

  ~MutexLock() {
    assert(0 == holder_);
    MCHECK(pthread_mutex_destroy(&mutex_));
  }

  bool isLockedByThisThread() const {
    return holder_ == CurrentThread::tid();
  }

  void assertLocked() const {
    assert(isLockedByThisThread());
  }

  void lock() {
    MCHECK(pthread_mutex_lock(&mutex_));
    assignHolder();
  }

  void unlock() {
    unassignHolder();
    MCHECK(pthread_mutex_unlock(&mutex_));
  }

  pthread_mutex_t *getPthreadMutex() {
    return &mutex_;
  }

private:
  friend class Condition;

  class UnassignGuard : Noncopyable {
  public:
    explicit UnassignGuard(MutexLock &owner) : owner_(owner) {
    }

    ~UnassignGuard() {
      owner_.assignHolder();
    }

  private:
    MutexLock &owner_;
  };

  void unassignHolder() {
    holder_ = 0;
  }

  void assignHolder() {
    holder_ = CurrentThread::tid();
  }

  pid_t           holder_;
  pthread_mutex_t mutex_;
};

class MutexLockGuard : Noncopyable {
public:
  explicit MutexLockGuard(MutexLock &owner) : lock_(owner) {
    lock_.lock();
  }

  ~MutexLockGuard() {
    lock_.unlock();
  }

private:
  MutexLock &lock_;
};

}  // namespace muduo

#endif /* __MUTEX_H__ */
```
### 对象的创建很简单
线程安全的对象构造做到以下几点：
1. 不要在构造函数中注册任何回调函数；
2. 不要在构造函数中将`this`传给跨线程对象；
3. 即使在构造函数的最后一行也不行。

### 线程安全的`Observer`有多难
`C/C++`指针问题根源： 无法有效判断一个指针是否合法。
### 神器`shared_ptr/weak_ptr`
`shared_ptr`的用法的关键点：
* `shared_ptr`控制对象生命周期。`shared_ptr`是强引用，只要存在引用该指针的对象就不会销毁。
* `weak_ptr`不控制生命周期。`weak_ptr`可以检测对象是否存活。
* `shared_ptr/weak_ptr`是原子操作，没有使用锁。
* `shared_ptr/weak_ptr`线程安全级别与`std::string、STL`相同。

`C++`可能出现的内存问题有以下：
1. 缓冲区溢出(`buffer overrun`)
2. 空悬指针/野指针
3. 重复释放(`double delete`)
4. 内存泄漏(`memory leak`)
5. 不配对的`new[]/delete`
6. 内存碎片(`memory fragmentation`)

对前5个问题的解决，可以采用如下方式：
1. 缓冲区溢出：用`std::vector<char>/std::string`或自己写的`Buffer Class`来管理缓冲区，自动标记缓冲区长度，通过成员函数不是裸指针修改缓冲区。
2. 空悬指针/野指针：使用`shared_ptr/weak_ptr`。
3. 重复释放：使用`scoped_ptr`，只在对象析构的时候释放一次。
4. 内存泄漏：用`scoped_ptr`，对象析构时自动释放内存。
5. 不配对的`new[]/delete`: 把`new[]`替换为`std::vector/scoped_array`。

`scoped_ptr/shared_ptr/weak_ptr`都是值语意，要么是栈上对象，要么是其他对象的直接数据成员，或是标准容器库的元素。
#### 再论`shared_ptr`的线程安全
`shared_ptr`本身不是`100%`线程安全的，对象的读写不是线程安全的。线程安全说明如下：
1. 一个`shared_ptr`对象实体可以被多个线程同时读取；
2. 两个`shared_ptr`对象实体可以被两个线程同时写入，析构算写入；
3. 如果要从多个线层读写同一个`shared_ptr`对象，需要加锁。





