## `C++`多线程编程精要
在多核系统中，多个线程是并行执行的，没有统一的时钟为每个事件编号。
### `C++`系统库的线程安全
主要在于定义内存模型(`memory model`)，特别是规定一个共享变量的修改何时能被其他线程看到，这成为内存序(`memory ordering`)，或内存可见度(`memory visibility`)。
系统调用对用户程序来说是原子性的，所以是线程安全的，但系统调用对内核状态的改变可能影响其他线程。
`c++`线程安全的基本原则：
1. 凡是非共享的对象都是独立的;
2. 共享对象的`read only`对象是安全的。

### `linux`上线程的标识
在`linux`系统上，`gettid`系统调用的返回值可以用作`线程id`：
1. 类型为`pid_t`,其值通常为一个小整数，便于日志输出；
2. 在现在`linux`系统中，他直接表示内核的任务调度`id`,因此在`/proc`中可以轻易找到对应项:`/proc/tid或/proc/pid/task/tid`；
3. 在其他系统工具中也容易定位到某个具体的线程；
4. 任何时刻都是全局唯一的，并且`linux`分配`pid`采用递增轮回的方法，短时间内启动多个线程也会具有不同的线程`id`;
5. `0`是非法值，因为每个操作系统第一个进程`init`的`pid=1`。

但每次调用这个系统调用`gettid`的开销较大，可以采用用`__thread`来缓存`gettid`的返回值，这样在每次线程第一次运行的时候缓存系统调用。
但这种方式存在一个问题：
如果进程执行了`fork()`, 子进程会不会看到`stale`的缓存结果？
解决的方案：
用`pthread_atfork`注册一个回调，用于清空缓存的线程`id`。

### 线程的创建和销毁的原则
简单原则：
1. 程序库不能在未提前告知的情况下创建自己的`背景线程`;
2. 尽量使用相同的方式创建线程;
3. 在进入`main`函数之前不应该启动线程；
4. 程序中线程的创建最好能在初始化阶段全部完成。

线程是稀缺资源，一个进程可以创建的线程受限于地址空间的大小和内核参数，一台机器可以并发运行的线程数受限于`CPU`的数目。
**`fork`的新进程与本进程通信方式选择，一般采用文件描述符的形式(`pipe,sockerpair,TCP socket`)来收发数据，不要采用共享内存和跨进程的互斥器等IPC.**
### `exit`在`C++`中不是线程安全的
`exit`函数作用有以下几根方面：
1. 终止进程；
2. 析构全局对象和已经构造完的函数静态对象。

这有潜在的死锁可能。

### 善用`__thread`关键字
`__thread`的使用规则：
1. 只能用于修饰`POD`类型，不能修饰`class`类型，因为无法自动调用构造函数和析构函数；
2. 可以修饰全局变量，函数内的静态变量，不能修饰函数的局部变量或者`class`的普通成员变量。

### 多线程与`IO`
操作文件的系统调用本身是线程安全的。

多线程可以加速磁盘`IO`么？
1. 首先要避免`lseek/read`的`race condition`，但多线程`read/write`一个文件不会提速。
2. 多个线程分别`read/write`同一个磁盘上的多个文件也不会提速，因为每个磁盘都有一个操作队列，多个线程的请求到了内核是排队执行的。

多线程磁盘`IO`的思路是：
每个磁盘配备一个线程，把所有对磁盘的`IO`都移动到同一个线程，避免或减少内核中的锁争用。

存在的两条例外：
1. 对磁盘文件在必要的时候，多个线程可以同时调用`pread/pwrite`读写同一个文件；
2. 对`UDP`, 由于协议本身保证消息的原子性，在适当的条件下(消息彼此独立)可以多个线程同时读写同一个`UDP`文件描述符。

`fork`之后,子进程继承了父进程的几乎全部状态，子进程会继承地址空间和文件描述符，因此用于管理动态内存和文件描述符的`RAII class`都能正常工作，但子进程不会继承：
* 父进程的内存锁(`mlock, mlockall`);
* 父进程的文件锁(`fcntl`);
* 父进程的某些定时器(`setitimer, alarm, timer_create`)；
* 其他。
### 多线程与`fork`
`fork`在多线程中不能很好的工作，因为`fork`只能拷贝当前线程的`pthread of control`，不克隆其他线程。这样其他线程不存在。

多线程中**不要使用`signal`**，包括：
1. 不要使用`signal`作为`IPC`手段，包括不要用`SIGUSR1`等触发服务端的行为；
2. 不要使用基于`signal`的定时函数，包括`alarm,ualarm,setitimer,time_create,sleep,usleep`等；
3. 不主动处理任何异常信号，除了`SIGPIPE`.
4. 如果没有别的替代的方法下，将异步信号转换为同步的文件描述符。





